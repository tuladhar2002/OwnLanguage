//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 4.6.6
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated from /Users/tuladhar2002/ComparitiveLanguageFinal/OwnLanguage/Content/Grammer.g4 by ANTLR 4.6.6

// Unreachable code detected
#pragma warning disable 0162
// The variable '...' is assigned but its value is never used
#pragma warning disable 0219
// Missing XML comment for publicly visible type or member '...'
#pragma warning disable 1591
// Ambiguous reference in cref attribute
#pragma warning disable 419

namespace OwnLanguage.Content {
using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using System.Collections.Generic;
using DFA = Antlr4.Runtime.Dfa.DFA;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.6.6")]
[System.CLSCompliant(false)]
public partial class GrammerParser : Parser {
	public const int
		T__0=1, T__1=2, T__2=3, T__3=4, T__4=5, T__5=6, T__6=7, T__7=8, T__8=9, 
		T__9=10, T__10=11, T__11=12, T__12=13, T__13=14, T__14=15, T__15=16, T__16=17, 
		T__17=18, T__18=19, T__19=20, T__20=21, T__21=22, T__22=23, T__23=24, 
		T__24=25, T__25=26, T__26=27, T__27=28, T__28=29, T__29=30, T__30=31, 
		T__31=32, T__32=33, WHILE=34, BOOL_OPERATOR=35, INTEGER=36, FLOAT=37, 
		STRING=38, NULL=39, BOOLEAN=40, WS=41, IDENTIFIER=42, IS_ASSIGN=43, Comment=44;
	public const int
		RULE_program = 0, RULE_line = 1, RULE_statement = 2, RULE_ifBlock = 3, 
		RULE_elseIfBlock = 4, RULE_block = 5, RULE_whileBlock = 6, RULE_assignment = 7, 
		RULE_printStatement = 8, RULE_functionCall = 9, RULE_expression = 10, 
		RULE_mult_op = 11, RULE_add_op = 12, RULE_comp_op = 13, RULE_bool_op = 14, 
		RULE_constant = 15;
	public static readonly string[] ruleNames = {
		"program", "line", "statement", "ifBlock", "elseIfBlock", "block", "whileBlock", 
		"assignment", "printStatement", "functionCall", "expression", "mult_op", 
		"add_op", "comp_op", "bool_op", "constant"
	};

	private static readonly string[] _LiteralNames = {
		null, "';'", "'if'", "'else'", "'{'", "'}'", "'='", "'show yourself'", 
		"'('", "')'", "','", "'!'", "'*'", "'/'", "'%'", "'times'", "'divided by'", 
		"'modulus'", "'+'", "'-'", "'plus'", "'minus'", "'=='", "'!='", "'<'", 
		"'<='", "'>'", "'>='", "'is equal to'", "'is not equal to'", "'is less than'", 
		"'is less than or equal to'", "'is greater than'", "'is greater than or equal to'", 
		null, null, null, null, null, "'null'", null, null, null, "'->'", "'//'"
	};
	private static readonly string[] _SymbolicNames = {
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, "WHILE", "BOOL_OPERATOR", 
		"INTEGER", "FLOAT", "STRING", "NULL", "BOOLEAN", "WS", "IDENTIFIER", "IS_ASSIGN", 
		"Comment"
	};
	public static readonly IVocabulary DefaultVocabulary = new Vocabulary(_LiteralNames, _SymbolicNames);

	[System.Obsolete("Use Vocabulary instead.")]
	public static readonly string[] tokenNames = GenerateTokenNames(DefaultVocabulary, _SymbolicNames.Length);

	private static string[] GenerateTokenNames(IVocabulary vocabulary, int length) {
		string[] tokenNames = new string[length];
		for (int i = 0; i < tokenNames.Length; i++) {
			tokenNames[i] = vocabulary.GetLiteralName(i);
			if (tokenNames[i] == null) {
				tokenNames[i] = vocabulary.GetSymbolicName(i);
			}

			if (tokenNames[i] == null) {
				tokenNames[i] = "<INVALID>";
			}
		}

		return tokenNames;
	}

	[System.Obsolete("Use IRecognizer.Vocabulary instead.")]
	public override string[] TokenNames
	{
		get
		{
			return tokenNames;
		}
	}

	[NotNull]
	public override IVocabulary Vocabulary
	{
		get
		{
			return DefaultVocabulary;
		}
	}

	public override string GrammarFileName { get { return "Grammer.g4"; } }

	public override string[] RuleNames { get { return ruleNames; } }

	public override string SerializedAtn { get { return _serializedATN; } }

	public GrammerParser(ITokenStream input)
		: base(input)
	{
		_interp = new ParserATNSimulator(this,_ATN);
	}
	public partial class ProgramContext : ParserRuleContext {
		public ITerminalNode Eof() { return GetToken(GrammerParser.Eof, 0); }
		public LineContext[] line() {
			return GetRuleContexts<LineContext>();
		}
		public LineContext line(int i) {
			return GetRuleContext<LineContext>(i);
		}
		public ProgramContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_program; } }
		public override void EnterRule(IParseTreeListener listener) {
			IGrammerListener typedListener = listener as IGrammerListener;
			if (typedListener != null) typedListener.EnterProgram(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGrammerListener typedListener = listener as IGrammerListener;
			if (typedListener != null) typedListener.ExitProgram(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGrammerVisitor<TResult> typedVisitor = visitor as IGrammerVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitProgram(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ProgramContext program() {
		ProgramContext _localctx = new ProgramContext(_ctx, State);
		EnterRule(_localctx, 0, RULE_program);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 35;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << T__1) | (1L << T__6) | (1L << WHILE) | (1L << IDENTIFIER))) != 0)) {
				{
				{
				State = 32; line();
				}
				}
				State = 37;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 38; Match(Eof);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LineContext : ParserRuleContext {
		public StatementContext statement() {
			return GetRuleContext<StatementContext>(0);
		}
		public IfBlockContext ifBlock() {
			return GetRuleContext<IfBlockContext>(0);
		}
		public WhileBlockContext whileBlock() {
			return GetRuleContext<WhileBlockContext>(0);
		}
		public LineContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_line; } }
		public override void EnterRule(IParseTreeListener listener) {
			IGrammerListener typedListener = listener as IGrammerListener;
			if (typedListener != null) typedListener.EnterLine(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGrammerListener typedListener = listener as IGrammerListener;
			if (typedListener != null) typedListener.ExitLine(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGrammerVisitor<TResult> typedVisitor = visitor as IGrammerVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLine(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LineContext line() {
		LineContext _localctx = new LineContext(_ctx, State);
		EnterRule(_localctx, 2, RULE_line);
		try {
			State = 43;
			_errHandler.Sync(this);
			switch (_input.La(1)) {
			case T__6:
			case IDENTIFIER:
				EnterOuterAlt(_localctx, 1);
				{
				State = 40; statement();
				}
				break;
			case T__1:
				EnterOuterAlt(_localctx, 2);
				{
				State = 41; ifBlock();
				}
				break;
			case WHILE:
				EnterOuterAlt(_localctx, 3);
				{
				State = 42; whileBlock();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StatementContext : ParserRuleContext {
		public AssignmentContext assignment() {
			return GetRuleContext<AssignmentContext>(0);
		}
		public PrintStatementContext printStatement() {
			return GetRuleContext<PrintStatementContext>(0);
		}
		public StatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_statement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IGrammerListener typedListener = listener as IGrammerListener;
			if (typedListener != null) typedListener.EnterStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGrammerListener typedListener = listener as IGrammerListener;
			if (typedListener != null) typedListener.ExitStatement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGrammerVisitor<TResult> typedVisitor = visitor as IGrammerVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StatementContext statement() {
		StatementContext _localctx = new StatementContext(_ctx, State);
		EnterRule(_localctx, 4, RULE_statement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 47;
			_errHandler.Sync(this);
			switch (_input.La(1)) {
			case IDENTIFIER:
				{
				State = 45; assignment();
				}
				break;
			case T__6:
				{
				State = 46; printStatement();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 49; Match(T__0);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IfBlockContext : ParserRuleContext {
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public BlockContext block() {
			return GetRuleContext<BlockContext>(0);
		}
		public ElseIfBlockContext elseIfBlock() {
			return GetRuleContext<ElseIfBlockContext>(0);
		}
		public IfBlockContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_ifBlock; } }
		public override void EnterRule(IParseTreeListener listener) {
			IGrammerListener typedListener = listener as IGrammerListener;
			if (typedListener != null) typedListener.EnterIfBlock(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGrammerListener typedListener = listener as IGrammerListener;
			if (typedListener != null) typedListener.ExitIfBlock(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGrammerVisitor<TResult> typedVisitor = visitor as IGrammerVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIfBlock(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public IfBlockContext ifBlock() {
		IfBlockContext _localctx = new IfBlockContext(_ctx, State);
		EnterRule(_localctx, 6, RULE_ifBlock);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 51; Match(T__1);
			State = 52; expression(0);
			State = 53; block();
			{
			State = 54; Match(T__2);
			State = 55; elseIfBlock();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ElseIfBlockContext : ParserRuleContext {
		public BlockContext block() {
			return GetRuleContext<BlockContext>(0);
		}
		public IfBlockContext ifBlock() {
			return GetRuleContext<IfBlockContext>(0);
		}
		public ElseIfBlockContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_elseIfBlock; } }
		public override void EnterRule(IParseTreeListener listener) {
			IGrammerListener typedListener = listener as IGrammerListener;
			if (typedListener != null) typedListener.EnterElseIfBlock(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGrammerListener typedListener = listener as IGrammerListener;
			if (typedListener != null) typedListener.ExitElseIfBlock(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGrammerVisitor<TResult> typedVisitor = visitor as IGrammerVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitElseIfBlock(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ElseIfBlockContext elseIfBlock() {
		ElseIfBlockContext _localctx = new ElseIfBlockContext(_ctx, State);
		EnterRule(_localctx, 8, RULE_elseIfBlock);
		try {
			State = 59;
			_errHandler.Sync(this);
			switch (_input.La(1)) {
			case T__3:
				EnterOuterAlt(_localctx, 1);
				{
				State = 57; block();
				}
				break;
			case T__1:
				EnterOuterAlt(_localctx, 2);
				{
				State = 58; ifBlock();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BlockContext : ParserRuleContext {
		public LineContext[] line() {
			return GetRuleContexts<LineContext>();
		}
		public LineContext line(int i) {
			return GetRuleContext<LineContext>(i);
		}
		public BlockContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_block; } }
		public override void EnterRule(IParseTreeListener listener) {
			IGrammerListener typedListener = listener as IGrammerListener;
			if (typedListener != null) typedListener.EnterBlock(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGrammerListener typedListener = listener as IGrammerListener;
			if (typedListener != null) typedListener.ExitBlock(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGrammerVisitor<TResult> typedVisitor = visitor as IGrammerVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBlock(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public BlockContext block() {
		BlockContext _localctx = new BlockContext(_ctx, State);
		EnterRule(_localctx, 10, RULE_block);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 61; Match(T__3);
			State = 65;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << T__1) | (1L << T__6) | (1L << WHILE) | (1L << IDENTIFIER))) != 0)) {
				{
				{
				State = 62; line();
				}
				}
				State = 67;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 68; Match(T__4);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class WhileBlockContext : ParserRuleContext {
		public ITerminalNode WHILE() { return GetToken(GrammerParser.WHILE, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public BlockContext block() {
			return GetRuleContext<BlockContext>(0);
		}
		public ElseIfBlockContext elseIfBlock() {
			return GetRuleContext<ElseIfBlockContext>(0);
		}
		public WhileBlockContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_whileBlock; } }
		public override void EnterRule(IParseTreeListener listener) {
			IGrammerListener typedListener = listener as IGrammerListener;
			if (typedListener != null) typedListener.EnterWhileBlock(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGrammerListener typedListener = listener as IGrammerListener;
			if (typedListener != null) typedListener.ExitWhileBlock(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGrammerVisitor<TResult> typedVisitor = visitor as IGrammerVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitWhileBlock(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public WhileBlockContext whileBlock() {
		WhileBlockContext _localctx = new WhileBlockContext(_ctx, State);
		EnterRule(_localctx, 12, RULE_whileBlock);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 70; Match(WHILE);
			State = 71; expression(0);
			State = 72; block();
			{
			State = 73; Match(T__2);
			State = 74; elseIfBlock();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AssignmentContext : ParserRuleContext {
		public ITerminalNode IDENTIFIER() { return GetToken(GrammerParser.IDENTIFIER, 0); }
		public ITerminalNode IS_ASSIGN() { return GetToken(GrammerParser.IS_ASSIGN, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public AssignmentContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_assignment; } }
		public override void EnterRule(IParseTreeListener listener) {
			IGrammerListener typedListener = listener as IGrammerListener;
			if (typedListener != null) typedListener.EnterAssignment(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGrammerListener typedListener = listener as IGrammerListener;
			if (typedListener != null) typedListener.ExitAssignment(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGrammerVisitor<TResult> typedVisitor = visitor as IGrammerVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAssignment(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AssignmentContext assignment() {
		AssignmentContext _localctx = new AssignmentContext(_ctx, State);
		EnterRule(_localctx, 14, RULE_assignment);
		try {
			State = 82;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,5,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 76; Match(IDENTIFIER);
				State = 77; Match(IS_ASSIGN);
				State = 78; expression(0);
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 79; Match(IDENTIFIER);
				State = 80; Match(T__5);
				State = 81; expression(0);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PrintStatementContext : ParserRuleContext {
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public PrintStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_printStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IGrammerListener typedListener = listener as IGrammerListener;
			if (typedListener != null) typedListener.EnterPrintStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGrammerListener typedListener = listener as IGrammerListener;
			if (typedListener != null) typedListener.ExitPrintStatement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGrammerVisitor<TResult> typedVisitor = visitor as IGrammerVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPrintStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PrintStatementContext printStatement() {
		PrintStatementContext _localctx = new PrintStatementContext(_ctx, State);
		EnterRule(_localctx, 16, RULE_printStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 84; Match(T__6);
			State = 85; Match(T__7);
			State = 86; expression(0);
			State = 87; Match(T__8);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FunctionCallContext : ParserRuleContext {
		public ITerminalNode IDENTIFIER() { return GetToken(GrammerParser.IDENTIFIER, 0); }
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public FunctionCallContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_functionCall; } }
		public override void EnterRule(IParseTreeListener listener) {
			IGrammerListener typedListener = listener as IGrammerListener;
			if (typedListener != null) typedListener.EnterFunctionCall(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGrammerListener typedListener = listener as IGrammerListener;
			if (typedListener != null) typedListener.ExitFunctionCall(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGrammerVisitor<TResult> typedVisitor = visitor as IGrammerVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunctionCall(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FunctionCallContext functionCall() {
		FunctionCallContext _localctx = new FunctionCallContext(_ctx, State);
		EnterRule(_localctx, 18, RULE_functionCall);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 89; Match(IDENTIFIER);
			State = 90; Match(T__7);
			State = 99;
			_errHandler.Sync(this);
			_la = _input.La(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << T__7) | (1L << T__10) | (1L << INTEGER) | (1L << FLOAT) | (1L << STRING) | (1L << NULL) | (1L << BOOLEAN) | (1L << IDENTIFIER))) != 0)) {
				{
				State = 91; expression(0);
				State = 96;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==T__9) {
					{
					{
					State = 92; Match(T__9);
					State = 93; expression(0);
					}
					}
					State = 98;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				}
			}

			State = 101; Match(T__8);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExpressionContext : ParserRuleContext {
		public ExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expression; } }
	 
		public ExpressionContext() { }
		public virtual void CopyFrom(ExpressionContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class ConstantExpressionContext : ExpressionContext {
		public ConstantContext constant() {
			return GetRuleContext<ConstantContext>(0);
		}
		public ConstantExpressionContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGrammerListener typedListener = listener as IGrammerListener;
			if (typedListener != null) typedListener.EnterConstantExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGrammerListener typedListener = listener as IGrammerListener;
			if (typedListener != null) typedListener.ExitConstantExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGrammerVisitor<TResult> typedVisitor = visitor as IGrammerVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitConstantExpression(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class IdentifierExpressionContext : ExpressionContext {
		public ITerminalNode IDENTIFIER() { return GetToken(GrammerParser.IDENTIFIER, 0); }
		public IdentifierExpressionContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGrammerListener typedListener = listener as IGrammerListener;
			if (typedListener != null) typedListener.EnterIdentifierExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGrammerListener typedListener = listener as IGrammerListener;
			if (typedListener != null) typedListener.ExitIdentifierExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGrammerVisitor<TResult> typedVisitor = visitor as IGrammerVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIdentifierExpression(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class FunctionCallExpressionContext : ExpressionContext {
		public FunctionCallContext functionCall() {
			return GetRuleContext<FunctionCallContext>(0);
		}
		public FunctionCallExpressionContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGrammerListener typedListener = listener as IGrammerListener;
			if (typedListener != null) typedListener.EnterFunctionCallExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGrammerListener typedListener = listener as IGrammerListener;
			if (typedListener != null) typedListener.ExitFunctionCallExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGrammerVisitor<TResult> typedVisitor = visitor as IGrammerVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunctionCallExpression(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ParenExpressionContext : ExpressionContext {
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ParenExpressionContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGrammerListener typedListener = listener as IGrammerListener;
			if (typedListener != null) typedListener.EnterParenExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGrammerListener typedListener = listener as IGrammerListener;
			if (typedListener != null) typedListener.ExitParenExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGrammerVisitor<TResult> typedVisitor = visitor as IGrammerVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitParenExpression(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class NotExpressionContext : ExpressionContext {
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public NotExpressionContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGrammerListener typedListener = listener as IGrammerListener;
			if (typedListener != null) typedListener.EnterNotExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGrammerListener typedListener = listener as IGrammerListener;
			if (typedListener != null) typedListener.ExitNotExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGrammerVisitor<TResult> typedVisitor = visitor as IGrammerVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNotExpression(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class MultExpressionContext : ExpressionContext {
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public Mult_opContext mult_op() {
			return GetRuleContext<Mult_opContext>(0);
		}
		public MultExpressionContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGrammerListener typedListener = listener as IGrammerListener;
			if (typedListener != null) typedListener.EnterMultExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGrammerListener typedListener = listener as IGrammerListener;
			if (typedListener != null) typedListener.ExitMultExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGrammerVisitor<TResult> typedVisitor = visitor as IGrammerVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMultExpression(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class AddExpressionContext : ExpressionContext {
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public Add_opContext add_op() {
			return GetRuleContext<Add_opContext>(0);
		}
		public AddExpressionContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGrammerListener typedListener = listener as IGrammerListener;
			if (typedListener != null) typedListener.EnterAddExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGrammerListener typedListener = listener as IGrammerListener;
			if (typedListener != null) typedListener.ExitAddExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGrammerVisitor<TResult> typedVisitor = visitor as IGrammerVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAddExpression(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class CompExpressionContext : ExpressionContext {
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public Comp_opContext comp_op() {
			return GetRuleContext<Comp_opContext>(0);
		}
		public CompExpressionContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGrammerListener typedListener = listener as IGrammerListener;
			if (typedListener != null) typedListener.EnterCompExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGrammerListener typedListener = listener as IGrammerListener;
			if (typedListener != null) typedListener.ExitCompExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGrammerVisitor<TResult> typedVisitor = visitor as IGrammerVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCompExpression(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class BoolExpressionContext : ExpressionContext {
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public Bool_opContext bool_op() {
			return GetRuleContext<Bool_opContext>(0);
		}
		public BoolExpressionContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IGrammerListener typedListener = listener as IGrammerListener;
			if (typedListener != null) typedListener.EnterBoolExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGrammerListener typedListener = listener as IGrammerListener;
			if (typedListener != null) typedListener.ExitBoolExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGrammerVisitor<TResult> typedVisitor = visitor as IGrammerVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBoolExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExpressionContext expression() {
		return expression(0);
	}

	private ExpressionContext expression(int _p) {
		ParserRuleContext _parentctx = _ctx;
		int _parentState = State;
		ExpressionContext _localctx = new ExpressionContext(_ctx, _parentState);
		ExpressionContext _prevctx = _localctx;
		int _startState = 20;
		EnterRecursionRule(_localctx, 20, RULE_expression, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 113;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,8,_ctx) ) {
			case 1:
				{
				_localctx = new ConstantExpressionContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;

				State = 104; constant();
				}
				break;

			case 2:
				{
				_localctx = new IdentifierExpressionContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;
				State = 105; Match(IDENTIFIER);
				}
				break;

			case 3:
				{
				_localctx = new FunctionCallExpressionContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;
				State = 106; functionCall();
				}
				break;

			case 4:
				{
				_localctx = new ParenExpressionContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;
				State = 107; Match(T__7);
				State = 108; expression(0);
				State = 109; Match(T__8);
				}
				break;

			case 5:
				{
				_localctx = new NotExpressionContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;
				State = 111; Match(T__10);
				State = 112; expression(5);
				}
				break;
			}
			_ctx.stop = _input.Lt(-1);
			State = 133;
			_errHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(_input,10,_ctx);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					if ( _parseListeners!=null ) TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					State = 131;
					_errHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(_input,9,_ctx) ) {
					case 1:
						{
						_localctx = new MultExpressionContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 115;
						if (!(Precpred(_ctx, 4))) throw new FailedPredicateException(this, "Precpred(_ctx, 4)");
						State = 116; mult_op();
						State = 117; expression(5);
						}
						break;

					case 2:
						{
						_localctx = new AddExpressionContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 119;
						if (!(Precpred(_ctx, 3))) throw new FailedPredicateException(this, "Precpred(_ctx, 3)");
						State = 120; add_op();
						State = 121; expression(4);
						}
						break;

					case 3:
						{
						_localctx = new CompExpressionContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 123;
						if (!(Precpred(_ctx, 2))) throw new FailedPredicateException(this, "Precpred(_ctx, 2)");
						State = 124; comp_op();
						State = 125; expression(3);
						}
						break;

					case 4:
						{
						_localctx = new BoolExpressionContext(new ExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 127;
						if (!(Precpred(_ctx, 1))) throw new FailedPredicateException(this, "Precpred(_ctx, 1)");
						State = 128; bool_op();
						State = 129; expression(2);
						}
						break;
					}
					} 
				}
				State = 135;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,10,_ctx);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class Mult_opContext : ParserRuleContext {
		public Mult_opContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_mult_op; } }
		public override void EnterRule(IParseTreeListener listener) {
			IGrammerListener typedListener = listener as IGrammerListener;
			if (typedListener != null) typedListener.EnterMult_op(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGrammerListener typedListener = listener as IGrammerListener;
			if (typedListener != null) typedListener.ExitMult_op(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGrammerVisitor<TResult> typedVisitor = visitor as IGrammerVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMult_op(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Mult_opContext mult_op() {
		Mult_opContext _localctx = new Mult_opContext(_ctx, State);
		EnterRule(_localctx, 22, RULE_mult_op);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 136;
			_la = _input.La(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << T__11) | (1L << T__12) | (1L << T__13) | (1L << T__14) | (1L << T__15) | (1L << T__16))) != 0)) ) {
			_errHandler.RecoverInline(this);
			} else {
				if (_input.La(1) == TokenConstants.Eof) {
					matchedEOF = true;
				}

				_errHandler.ReportMatch(this);
				Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Add_opContext : ParserRuleContext {
		public Add_opContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_add_op; } }
		public override void EnterRule(IParseTreeListener listener) {
			IGrammerListener typedListener = listener as IGrammerListener;
			if (typedListener != null) typedListener.EnterAdd_op(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGrammerListener typedListener = listener as IGrammerListener;
			if (typedListener != null) typedListener.ExitAdd_op(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGrammerVisitor<TResult> typedVisitor = visitor as IGrammerVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAdd_op(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Add_opContext add_op() {
		Add_opContext _localctx = new Add_opContext(_ctx, State);
		EnterRule(_localctx, 24, RULE_add_op);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 138;
			_la = _input.La(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << T__17) | (1L << T__18) | (1L << T__19) | (1L << T__20))) != 0)) ) {
			_errHandler.RecoverInline(this);
			} else {
				if (_input.La(1) == TokenConstants.Eof) {
					matchedEOF = true;
				}

				_errHandler.ReportMatch(this);
				Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Comp_opContext : ParserRuleContext {
		public Comp_opContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_comp_op; } }
		public override void EnterRule(IParseTreeListener listener) {
			IGrammerListener typedListener = listener as IGrammerListener;
			if (typedListener != null) typedListener.EnterComp_op(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGrammerListener typedListener = listener as IGrammerListener;
			if (typedListener != null) typedListener.ExitComp_op(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGrammerVisitor<TResult> typedVisitor = visitor as IGrammerVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitComp_op(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Comp_opContext comp_op() {
		Comp_opContext _localctx = new Comp_opContext(_ctx, State);
		EnterRule(_localctx, 26, RULE_comp_op);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 140;
			_la = _input.La(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << T__21) | (1L << T__22) | (1L << T__23) | (1L << T__24) | (1L << T__25) | (1L << T__26) | (1L << T__27) | (1L << T__28) | (1L << T__29) | (1L << T__30) | (1L << T__31) | (1L << T__32))) != 0)) ) {
			_errHandler.RecoverInline(this);
			} else {
				if (_input.La(1) == TokenConstants.Eof) {
					matchedEOF = true;
				}

				_errHandler.ReportMatch(this);
				Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Bool_opContext : ParserRuleContext {
		public ITerminalNode BOOL_OPERATOR() { return GetToken(GrammerParser.BOOL_OPERATOR, 0); }
		public Bool_opContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_bool_op; } }
		public override void EnterRule(IParseTreeListener listener) {
			IGrammerListener typedListener = listener as IGrammerListener;
			if (typedListener != null) typedListener.EnterBool_op(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGrammerListener typedListener = listener as IGrammerListener;
			if (typedListener != null) typedListener.ExitBool_op(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGrammerVisitor<TResult> typedVisitor = visitor as IGrammerVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBool_op(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Bool_opContext bool_op() {
		Bool_opContext _localctx = new Bool_opContext(_ctx, State);
		EnterRule(_localctx, 28, RULE_bool_op);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 142; Match(BOOL_OPERATOR);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ConstantContext : ParserRuleContext {
		public ITerminalNode INTEGER() { return GetToken(GrammerParser.INTEGER, 0); }
		public ITerminalNode FLOAT() { return GetToken(GrammerParser.FLOAT, 0); }
		public ITerminalNode STRING() { return GetToken(GrammerParser.STRING, 0); }
		public ITerminalNode BOOLEAN() { return GetToken(GrammerParser.BOOLEAN, 0); }
		public ITerminalNode NULL() { return GetToken(GrammerParser.NULL, 0); }
		public ConstantContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_constant; } }
		public override void EnterRule(IParseTreeListener listener) {
			IGrammerListener typedListener = listener as IGrammerListener;
			if (typedListener != null) typedListener.EnterConstant(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IGrammerListener typedListener = listener as IGrammerListener;
			if (typedListener != null) typedListener.ExitConstant(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGrammerVisitor<TResult> typedVisitor = visitor as IGrammerVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitConstant(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ConstantContext constant() {
		ConstantContext _localctx = new ConstantContext(_ctx, State);
		EnterRule(_localctx, 30, RULE_constant);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 144;
			_la = _input.La(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << INTEGER) | (1L << FLOAT) | (1L << STRING) | (1L << NULL) | (1L << BOOLEAN))) != 0)) ) {
			_errHandler.RecoverInline(this);
			} else {
				if (_input.La(1) == TokenConstants.Eof) {
					matchedEOF = true;
				}

				_errHandler.ReportMatch(this);
				Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public override bool Sempred(RuleContext _localctx, int ruleIndex, int predIndex) {
		switch (ruleIndex) {
		case 10: return expression_sempred((ExpressionContext)_localctx, predIndex);
		}
		return true;
	}
	private bool expression_sempred(ExpressionContext _localctx, int predIndex) {
		switch (predIndex) {
		case 0: return Precpred(_ctx, 4);

		case 1: return Precpred(_ctx, 3);

		case 2: return Precpred(_ctx, 2);

		case 3: return Precpred(_ctx, 1);
		}
		return true;
	}

	public static readonly string _serializedATN =
		"\x3\xAF6F\x8320\x479D\xB75C\x4880\x1605\x191C\xAB37\x3.\x95\x4\x2\t\x2"+
		"\x4\x3\t\x3\x4\x4\t\x4\x4\x5\t\x5\x4\x6\t\x6\x4\a\t\a\x4\b\t\b\x4\t\t"+
		"\t\x4\n\t\n\x4\v\t\v\x4\f\t\f\x4\r\t\r\x4\xE\t\xE\x4\xF\t\xF\x4\x10\t"+
		"\x10\x4\x11\t\x11\x3\x2\a\x2$\n\x2\f\x2\xE\x2\'\v\x2\x3\x2\x3\x2\x3\x3"+
		"\x3\x3\x3\x3\x5\x3.\n\x3\x3\x4\x3\x4\x5\x4\x32\n\x4\x3\x4\x3\x4\x3\x5"+
		"\x3\x5\x3\x5\x3\x5\x3\x5\x3\x5\x3\x6\x3\x6\x5\x6>\n\x6\x3\a\x3\a\a\a\x42"+
		"\n\a\f\a\xE\a\x45\v\a\x3\a\x3\a\x3\b\x3\b\x3\b\x3\b\x3\b\x3\b\x3\t\x3"+
		"\t\x3\t\x3\t\x3\t\x3\t\x5\tU\n\t\x3\n\x3\n\x3\n\x3\n\x3\n\x3\v\x3\v\x3"+
		"\v\x3\v\x3\v\a\v\x61\n\v\f\v\xE\v\x64\v\v\x5\v\x66\n\v\x3\v\x3\v\x3\f"+
		"\x3\f\x3\f\x3\f\x3\f\x3\f\x3\f\x3\f\x3\f\x3\f\x5\ft\n\f\x3\f\x3\f\x3\f"+
		"\x3\f\x3\f\x3\f\x3\f\x3\f\x3\f\x3\f\x3\f\x3\f\x3\f\x3\f\x3\f\x3\f\a\f"+
		"\x86\n\f\f\f\xE\f\x89\v\f\x3\r\x3\r\x3\xE\x3\xE\x3\xF\x3\xF\x3\x10\x3"+
		"\x10\x3\x11\x3\x11\x3\x11\x2\x2\x3\x16\x12\x2\x2\x4\x2\x6\x2\b\x2\n\x2"+
		"\f\x2\xE\x2\x10\x2\x12\x2\x14\x2\x16\x2\x18\x2\x1A\x2\x1C\x2\x1E\x2 \x2"+
		"\x2\x6\x3\x2\xE\x13\x3\x2\x14\x17\x3\x2\x18#\x3\x2&*\x95\x2%\x3\x2\x2"+
		"\x2\x4-\x3\x2\x2\x2\x6\x31\x3\x2\x2\x2\b\x35\x3\x2\x2\x2\n=\x3\x2\x2\x2"+
		"\f?\x3\x2\x2\x2\xEH\x3\x2\x2\x2\x10T\x3\x2\x2\x2\x12V\x3\x2\x2\x2\x14"+
		"[\x3\x2\x2\x2\x16s\x3\x2\x2\x2\x18\x8A\x3\x2\x2\x2\x1A\x8C\x3\x2\x2\x2"+
		"\x1C\x8E\x3\x2\x2\x2\x1E\x90\x3\x2\x2\x2 \x92\x3\x2\x2\x2\"$\x5\x4\x3"+
		"\x2#\"\x3\x2\x2\x2$\'\x3\x2\x2\x2%#\x3\x2\x2\x2%&\x3\x2\x2\x2&(\x3\x2"+
		"\x2\x2\'%\x3\x2\x2\x2()\a\x2\x2\x3)\x3\x3\x2\x2\x2*.\x5\x6\x4\x2+.\x5"+
		"\b\x5\x2,.\x5\xE\b\x2-*\x3\x2\x2\x2-+\x3\x2\x2\x2-,\x3\x2\x2\x2.\x5\x3"+
		"\x2\x2\x2/\x32\x5\x10\t\x2\x30\x32\x5\x12\n\x2\x31/\x3\x2\x2\x2\x31\x30"+
		"\x3\x2\x2\x2\x32\x33\x3\x2\x2\x2\x33\x34\a\x3\x2\x2\x34\a\x3\x2\x2\x2"+
		"\x35\x36\a\x4\x2\x2\x36\x37\x5\x16\f\x2\x37\x38\x5\f\a\x2\x38\x39\a\x5"+
		"\x2\x2\x39:\x5\n\x6\x2:\t\x3\x2\x2\x2;>\x5\f\a\x2<>\x5\b\x5\x2=;\x3\x2"+
		"\x2\x2=<\x3\x2\x2\x2>\v\x3\x2\x2\x2?\x43\a\x6\x2\x2@\x42\x5\x4\x3\x2\x41"+
		"@\x3\x2\x2\x2\x42\x45\x3\x2\x2\x2\x43\x41\x3\x2\x2\x2\x43\x44\x3\x2\x2"+
		"\x2\x44\x46\x3\x2\x2\x2\x45\x43\x3\x2\x2\x2\x46G\a\a\x2\x2G\r\x3\x2\x2"+
		"\x2HI\a$\x2\x2IJ\x5\x16\f\x2JK\x5\f\a\x2KL\a\x5\x2\x2LM\x5\n\x6\x2M\xF"+
		"\x3\x2\x2\x2NO\a,\x2\x2OP\a-\x2\x2PU\x5\x16\f\x2QR\a,\x2\x2RS\a\b\x2\x2"+
		"SU\x5\x16\f\x2TN\x3\x2\x2\x2TQ\x3\x2\x2\x2U\x11\x3\x2\x2\x2VW\a\t\x2\x2"+
		"WX\a\n\x2\x2XY\x5\x16\f\x2YZ\a\v\x2\x2Z\x13\x3\x2\x2\x2[\\\a,\x2\x2\\"+
		"\x65\a\n\x2\x2]\x62\x5\x16\f\x2^_\a\f\x2\x2_\x61\x5\x16\f\x2`^\x3\x2\x2"+
		"\x2\x61\x64\x3\x2\x2\x2\x62`\x3\x2\x2\x2\x62\x63\x3\x2\x2\x2\x63\x66\x3"+
		"\x2\x2\x2\x64\x62\x3\x2\x2\x2\x65]\x3\x2\x2\x2\x65\x66\x3\x2\x2\x2\x66"+
		"g\x3\x2\x2\x2gh\a\v\x2\x2h\x15\x3\x2\x2\x2ij\b\f\x1\x2jt\x5 \x11\x2kt"+
		"\a,\x2\x2lt\x5\x14\v\x2mn\a\n\x2\x2no\x5\x16\f\x2op\a\v\x2\x2pt\x3\x2"+
		"\x2\x2qr\a\r\x2\x2rt\x5\x16\f\asi\x3\x2\x2\x2sk\x3\x2\x2\x2sl\x3\x2\x2"+
		"\x2sm\x3\x2\x2\x2sq\x3\x2\x2\x2t\x87\x3\x2\x2\x2uv\f\x6\x2\x2vw\x5\x18"+
		"\r\x2wx\x5\x16\f\ax\x86\x3\x2\x2\x2yz\f\x5\x2\x2z{\x5\x1A\xE\x2{|\x5\x16"+
		"\f\x6|\x86\x3\x2\x2\x2}~\f\x4\x2\x2~\x7F\x5\x1C\xF\x2\x7F\x80\x5\x16\f"+
		"\x5\x80\x86\x3\x2\x2\x2\x81\x82\f\x3\x2\x2\x82\x83\x5\x1E\x10\x2\x83\x84"+
		"\x5\x16\f\x4\x84\x86\x3\x2\x2\x2\x85u\x3\x2\x2\x2\x85y\x3\x2\x2\x2\x85"+
		"}\x3\x2\x2\x2\x85\x81\x3\x2\x2\x2\x86\x89\x3\x2\x2\x2\x87\x85\x3\x2\x2"+
		"\x2\x87\x88\x3\x2\x2\x2\x88\x17\x3\x2\x2\x2\x89\x87\x3\x2\x2\x2\x8A\x8B"+
		"\t\x2\x2\x2\x8B\x19\x3\x2\x2\x2\x8C\x8D\t\x3\x2\x2\x8D\x1B\x3\x2\x2\x2"+
		"\x8E\x8F\t\x4\x2\x2\x8F\x1D\x3\x2\x2\x2\x90\x91\a%\x2\x2\x91\x1F\x3\x2"+
		"\x2\x2\x92\x93\t\x5\x2\x2\x93!\x3\x2\x2\x2\r%-\x31=\x43T\x62\x65s\x85"+
		"\x87";
	public static readonly ATN _ATN =
		new ATNDeserializer().Deserialize(_serializedATN.ToCharArray());
}
} // namespace OwnLanguage.Content
